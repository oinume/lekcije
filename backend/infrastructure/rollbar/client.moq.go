// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package rollbar

import (
	"context"
	"github.com/rollbar/rollbar-go"
	"sync"
)

// Ensure, that ClientMock does implement Client.
// If this is not the case, regenerate this file with moq.
var _ Client = &ClientMock{}

// ClientMock is a mock implementation of Client.
//
// 	func TestSomethingThatUsesClient(t *testing.T) {
//
// 		// make and configure a mocked Client
// 		mockedClient := &ClientMock{
// 			ErrorWithStackSkipWithExtrasAndContextFunc: func(ctx context.Context, level string, err error, skip int, extras map[string]interface{})  {
// 				panic("mock out the ErrorWithStackSkipWithExtrasAndContext method")
// 			},
// 			SetStackTracerFunc: func(stackTracer rollbar.StackTracerFunc)  {
// 				panic("mock out the SetStackTracer method")
// 			},
// 		}
//
// 		// use mockedClient in code that requires Client
// 		// and then make assertions.
//
// 	}
type ClientMock struct {
	// ErrorWithStackSkipWithExtrasAndContextFunc mocks the ErrorWithStackSkipWithExtrasAndContext method.
	ErrorWithStackSkipWithExtrasAndContextFunc func(ctx context.Context, level string, err error, skip int, extras map[string]interface{})

	// SetStackTracerFunc mocks the SetStackTracer method.
	SetStackTracerFunc func(stackTracer rollbar.StackTracerFunc)

	// calls tracks calls to the methods.
	calls struct {
		// ErrorWithStackSkipWithExtrasAndContext holds details about calls to the ErrorWithStackSkipWithExtrasAndContext method.
		ErrorWithStackSkipWithExtrasAndContext []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Level is the level argument value.
			Level string
			// Err is the err argument value.
			Err error
			// Skip is the skip argument value.
			Skip int
			// Extras is the extras argument value.
			Extras map[string]interface{}
		}
		// SetStackTracer holds details about calls to the SetStackTracer method.
		SetStackTracer []struct {
			// StackTracer is the stackTracer argument value.
			StackTracer rollbar.StackTracerFunc
		}
	}
	lockErrorWithStackSkipWithExtrasAndContext sync.RWMutex
	lockSetStackTracer                         sync.RWMutex
}

// ErrorWithStackSkipWithExtrasAndContext calls ErrorWithStackSkipWithExtrasAndContextFunc.
func (mock *ClientMock) ErrorWithStackSkipWithExtrasAndContext(ctx context.Context, level string, err error, skip int, extras map[string]interface{}) {
	if mock.ErrorWithStackSkipWithExtrasAndContextFunc == nil {
		panic("ClientMock.ErrorWithStackSkipWithExtrasAndContextFunc: method is nil but Client.ErrorWithStackSkipWithExtrasAndContext was just called")
	}
	callInfo := struct {
		Ctx    context.Context
		Level  string
		Err    error
		Skip   int
		Extras map[string]interface{}
	}{
		Ctx:    ctx,
		Level:  level,
		Err:    err,
		Skip:   skip,
		Extras: extras,
	}
	mock.lockErrorWithStackSkipWithExtrasAndContext.Lock()
	mock.calls.ErrorWithStackSkipWithExtrasAndContext = append(mock.calls.ErrorWithStackSkipWithExtrasAndContext, callInfo)
	mock.lockErrorWithStackSkipWithExtrasAndContext.Unlock()
	mock.ErrorWithStackSkipWithExtrasAndContextFunc(ctx, level, err, skip, extras)
}

// ErrorWithStackSkipWithExtrasAndContextCalls gets all the calls that were made to ErrorWithStackSkipWithExtrasAndContext.
// Check the length with:
//     len(mockedClient.ErrorWithStackSkipWithExtrasAndContextCalls())
func (mock *ClientMock) ErrorWithStackSkipWithExtrasAndContextCalls() []struct {
	Ctx    context.Context
	Level  string
	Err    error
	Skip   int
	Extras map[string]interface{}
} {
	var calls []struct {
		Ctx    context.Context
		Level  string
		Err    error
		Skip   int
		Extras map[string]interface{}
	}
	mock.lockErrorWithStackSkipWithExtrasAndContext.RLock()
	calls = mock.calls.ErrorWithStackSkipWithExtrasAndContext
	mock.lockErrorWithStackSkipWithExtrasAndContext.RUnlock()
	return calls
}

// SetStackTracer calls SetStackTracerFunc.
func (mock *ClientMock) SetStackTracer(stackTracer rollbar.StackTracerFunc) {
	if mock.SetStackTracerFunc == nil {
		panic("ClientMock.SetStackTracerFunc: method is nil but Client.SetStackTracer was just called")
	}
	callInfo := struct {
		StackTracer rollbar.StackTracerFunc
	}{
		StackTracer: stackTracer,
	}
	mock.lockSetStackTracer.Lock()
	mock.calls.SetStackTracer = append(mock.calls.SetStackTracer, callInfo)
	mock.lockSetStackTracer.Unlock()
	mock.SetStackTracerFunc(stackTracer)
}

// SetStackTracerCalls gets all the calls that were made to SetStackTracer.
// Check the length with:
//     len(mockedClient.SetStackTracerCalls())
func (mock *ClientMock) SetStackTracerCalls() []struct {
	StackTracer rollbar.StackTracerFunc
} {
	var calls []struct {
		StackTracer rollbar.StackTracerFunc
	}
	mock.lockSetStackTracer.RLock()
	calls = mock.calls.SetStackTracer
	mock.lockSetStackTracer.RUnlock()
	return calls
}
